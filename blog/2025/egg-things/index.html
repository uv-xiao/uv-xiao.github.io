<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> What if You Never Had to Choose? A Journey into E-graphs and Equality Saturation | uv-xiao </title> <meta name="author" content="Youwei Xiao"> <meta name="description" content="How e-graphs turn the optimizer's dilemma into a solved problem by keeping all the good ideas at once, featuring real examples, bad jokes, and the magic of egg"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-table@1.22.4/dist/bootstrap-table.min.css" integrity="sha256-uRX+PiRTR4ysKFRCykT8HLuRCub26LgXJZym3Yeom1c=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css2?family=Share+Tech&amp;family=Share+Tech+Mono&amp;family=Indie+Flower:wght@400&amp;family=Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link defer href="/assets/css/bootstrap-toc.min.css?6f5af0bb9aab25d79b2448143cbeaa88" rel="stylesheet"> <link defer rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pseudocode@2.4.1/build/pseudocode.min.css" integrity="sha256-VwMV//xgBPDyRFVSOshhRhzJRDyBmIACniLPpeXNUdc=" crossorigin="anonymous"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%E2%9A%9B%EF%B8%8F&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://uv-xiao.github.io/blog/2025/egg-things/"> <script src="/assets/js/theme.js?9a0c749ec5240d9cda97bc72359a72c0"></script> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>initTheme();</script> <link defer rel="stylesheet" type="text/css" href="https://tikzjax.com/v1/fonts.css"> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> uv-xiao </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">About </a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">Blog </a> </li> <li class="nav-item"> <button id="search-toggle" title="Search" onclick="openSearchModal()"> <span class="nav-link">ctrl k <i class="ti ti-search"></i></span> </button> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5" role="main"> <div class="row"> <div class="col-sm-3"> <nav id="toc-sidebar" class="sticky-top"></nav> </div> <div class="col-sm-9"> <div class="post"> <header class="post-header"> <h1 class="post-title">What if You Never Had to Choose? A Journey into E-graphs and Equality Saturation</h1> <p class="post-meta"> Created in July 02, 2025 </p> <p class="post-tags"> <a href="/blog/2025"> <i class="fa-solid fa-calendar fa-sm"></i> 2025 </a> ¬† ¬∑ ¬† <a href="/blog/tag/term-rewriting"> <i class="fa-solid fa-hashtag fa-sm"></i> term-rewriting</a> ¬† <a href="/blog/tag/e-graphs"> <i class="fa-solid fa-hashtag fa-sm"></i> e-graphs</a> ¬† <a href="/blog/tag/optimization"> <i class="fa-solid fa-hashtag fa-sm"></i> optimization</a> ¬† ¬∑ ¬† <a href="/blog/category/survey"> <i class="fa-solid fa-tag fa-sm"></i> survey</a> </p> </header> <article class="post-content"> <div id="table-of-contents"> <ul id="toc" class="section-nav"> <li class="toc-entry toc-h2"><a href="#the-problem-why-traditional-optimization-is-like-playing-jenga">The Problem: Why Traditional Optimization is Like Playing Jenga</a></li> <li class="toc-entry toc-h2"> <a href="#term-rewriting-the-old-school-approach">Term Rewriting: The Old School Approach</a> <ul> <li class="toc-entry toc-h3"><a href="#how-it-works-the-cookbook-analogy">How It Works (The Cookbook Analogy)</a></li> <li class="toc-entry toc-h3"><a href="#the-problems-why-this-gets-messy-fast">The Problems: Why This Gets Messy Fast</a></li> <li class="toc-entry toc-h3"><a href="#the-band-aid-rewrite-strategies">The Band-Aid: Rewrite Strategies</a></li> </ul> </li> <li class="toc-entry toc-h2"> <a href="#e-graphs-the-keep-everything-revolution">E-graphs: The ‚ÄúKeep Everything‚Äù Revolution</a> <ul> <li class="toc-entry toc-h3"><a href="#the-big-idea-detectives-corkboard-analogy">The Big Idea (Detective‚Äôs Corkboard Analogy)</a></li> <li class="toc-entry toc-h3"><a href="#how-e-graphs-actually-work">How E-graphs Actually Work</a></li> <li class="toc-entry toc-h3"><a href="#the-e-graph-api-just-four-operations">The E-graph API: Just Four Operations</a></li> <li class="toc-entry toc-h3"><a href="#e-matching-finding-patterns-in-the-chaos">E-matching: Finding Patterns in the Chaos</a></li> <li class="toc-entry toc-h3"><a href="#the-magic-non-destructive-rewriting">The Magic: Non-Destructive Rewriting</a></li> <li class="toc-entry toc-h3"><a href="#visual-example-the-old-way-vs-the-e-graph-way">Visual Example: The Old Way vs. The E-graph Way</a></li> </ul> </li> <li class="toc-entry toc-h2"> <a href="#equality-saturation-going-full-detective-mode">Equality Saturation: Going Full Detective Mode</a> <ul> <li class="toc-entry toc-h3"><a href="#the-phase-ordering-problem-why-order-matters">The Phase Ordering Problem (Why Order Matters)</a></li> <li class="toc-entry toc-h3"><a href="#equality-saturation-the-try-everything-algorithm">Equality Saturation: The ‚ÄúTry Everything‚Äù Algorithm</a></li> <li class="toc-entry toc-h3"> <a href="#extraction-picking-the-best-from-the-buffet">Extraction: Picking the Best from the Buffet</a> <ul> <li class="toc-entry toc-h4"><a href="#approach-1-the-mathematicians-solution-ilp">Approach 1: The Mathematician‚Äôs Solution (ILP)</a></li> <li class="toc-entry toc-h4"><a href="#approach-2-the-graph-theorists-dream-dynamic-programming">Approach 2: The Graph Theorist‚Äôs Dream (Dynamic Programming)</a></li> <li class="toc-entry toc-h4"><a href="#approach-3-the-engineers-good-enough-heuristics">Approach 3: The Engineer‚Äôs ‚ÄúGood Enough‚Äù (Heuristics)</a></li> </ul> </li> </ul> </li> <li class="toc-entry toc-h2"> <a href="#enter-egg-the-game-changer-">Enter egg: The Game Changer ü•ö</a> <ul> <li class="toc-entry toc-h3"><a href="#why-egg-changed-everything">Why egg Changed Everything</a></li> <li class="toc-entry toc-h3"><a href="#e-class-analysis-making-your-e-graph-smart">E-class Analysis: Making Your E-graph Smart</a></li> <li class="toc-entry toc-h3"><a href="#conditional-rewrites-smart-optimizations">Conditional Rewrites: Smart Optimizations</a></li> </ul> </li> <li class="toc-entry toc-h2"><a href="#quick-comparison-traditional-vs-e-graphs">Quick Comparison: Traditional vs E-graphs</a></li> <li class="toc-entry toc-h2"> <a href="#real-world-success-stories">Real-World Success Stories</a> <ul> <li class="toc-entry toc-h3"><a href="#herbie-making-floating-point-math-not-suck">Herbie: Making Floating-Point Math Not Suck</a></li> <li class="toc-entry toc-h3"><a href="#hardware-design-making-chips-cheaper">Hardware Design: Making Chips Cheaper</a></li> <li class="toc-entry toc-h3"><a href="#compiler-magic-cranelift-and-friends">Compiler Magic: Cranelift and Friends</a></li> </ul> </li> <li class="toc-entry toc-h2"> <a href="#egglog-the-next-generation-">Egglog: The Next Generation ü§Ø</a> <ul> <li class="toc-entry toc-h3"><a href="#what-if-e-graphs-could-think">What if E-graphs Could Think?</a></li> <li class="toc-entry toc-h3"><a href="#egglog-superpowers">Egglog Superpowers</a></li> </ul> </li> <li class="toc-entry toc-h2"> <a href="#the-future-where-this-is-all-going">The Future: Where This is All Going</a> <ul> <li class="toc-entry toc-h3"><a href="#the-scalability-wall">The Scalability Wall</a></li> <li class="toc-entry toc-h3"><a href="#ml--e-graphs--%EF%B8%8F">ML + E-graphs = ‚ù§Ô∏è</a></li> <li class="toc-entry toc-h3"><a href="#the-theory-gap">The Theory Gap</a></li> </ul> </li> <li class="toc-entry toc-h2"> <a href="#wrapping-up-why-this-matters">Wrapping Up: Why This Matters</a> <ul> <li class="toc-entry toc-h3"><a href="#the-journey-so-far">The Journey So Far</a></li> <li class="toc-entry toc-h3"><a href="#why-you-should-care">Why You Should Care</a></li> <li class="toc-entry toc-h3"><a href="#my-take">My Take</a></li> <li class="toc-entry toc-h3"><a href="#the-bottom-line">The Bottom Line</a></li> </ul> </li> </ul> </div> <hr> <div id="markdown-content"> <iframe src="https://uv-xiao.github.io/assets/slide/egg" width="100%" height="500px" frameborder="0" allowfullscreen=""></iframe> <p>I still remember my first serious attempt at writing a compiler optimizer. I had this clever rule: <code class="language-plaintext highlighter-rouge">(a * 2) / 2 ‚Üí a</code>. Simple, right? But then I realized that by eagerly applying it, I was destroying the pattern <code class="language-plaintext highlighter-rouge">(a * 2)</code> that another rule needed for vectorization. This is the optimizer‚Äôs eternal dilemma: every choice you make closes doors to other opportunities.</p> <p>For decades, we‚Äôve played this high-stakes game of optimization whack-a-mole, carefully ordering our transformations and hoping we don‚Äôt paint ourselves into a corner. But what if I told you there‚Äôs a way to have your cake and eat it too? What if you could apply ALL your optimizations at once and then pick the best result?</p> <p>Welcome to the world of <strong>e-graphs</strong> and <strong>equality saturation</strong> - where we don‚Äôt choose between optimizations, we choose from <em>all possible</em> optimizations. It‚Äôs like having a time machine for your compiler passes, except it actually works.</p> <h2 id="the-problem-why-traditional-optimization-is-like-playing-jenga">The Problem: Why Traditional Optimization is Like Playing Jenga</h2> <p>Before we dive into the solution, let‚Äôs understand why optimization is so darn hard. Traditional compilers use <strong>term rewriting</strong> - they see a pattern in your code and replace it with something better. Sounds great, right? Well‚Ä¶</p> <h2 id="term-rewriting-the-old-school-approach">Term Rewriting: The Old School Approach</h2> <h3 id="how-it-works-the-cookbook-analogy">How It Works (The Cookbook Analogy)</h3> <p>Think of <strong>term rewriting</strong> [Baader &amp; Nipkow, ‚ÄúTerm rewriting and all that,‚Äù 1998] like following a very literal recipe. You have your ingredients (the program), and a set of substitution rules (the recipe steps). When you see ‚Äú2 cups of sugar‚Äù, you can replace it with ‚Äú1 cup of honey‚Äù.</p> <p>In programming terms:</p> <ul> <li> <strong>Terms</strong>: Your code expressions, like <code class="language-plaintext highlighter-rouge">(a + 0) + (b + 0)</code> </li> <li> <strong>Rules</strong>: Transformations like ‚Äúx + 0 ‚Üí x‚Äù (because adding zero is pointless)</li> <li> <strong>Context</strong>: The surrounding code that doesn‚Äôt change</li> </ul> <p><strong>A Simple Example:</strong> Let‚Äôs optimize <code class="language-plaintext highlighter-rouge">(a + 0) + (b + 0)</code> with the rule <code class="language-plaintext highlighter-rouge">x + 0 ‚Üí x</code>:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Original: (a + 0) + (b + 0)
Apply rule to first part: a + (b + 0)
Apply rule to second part: a + b
</code></pre></div></div> <p>Seems great! But here‚Äôs the catch‚Ä¶</p> <h3 id="the-problems-why-this-gets-messy-fast">The Problems: Why This Gets Messy Fast</h3> <p><strong>The Termination Trap:</strong> Sometimes rules can ping-pong forever:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>x + y ‚Üí y + x  (commutivity)
y + x ‚Üí x + y  (oops, infinite loop!)
</code></pre></div></div> <p><strong>The Confluence Conundrum:</strong> Different rule orders give different results:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(a * 2) / 2
  ‚Üì (optimize multiply)     ‚Üì (optimize divide)
(a &lt;&lt; 1) / 2                a * (2/2)
  ‚Üì                         ‚Üì
???                         a
</code></pre></div></div> <p>One path leads to <code class="language-plaintext highlighter-rouge">a</code>, the other to‚Ä¶ who knows? This is why compiler writers lose sleep.</p> <h3 id="the-band-aid-rewrite-strategies">The Band-Aid: Rewrite Strategies</h3> <p>Compiler writers tried to fix this with ‚Äústrategies‚Äù - basically recipes for <em>how</em> to apply rules. It‚Äôs like saying ‚Äúalways start cooking from the outside in‚Äù or ‚Äúseason as you go‚Äù.</p> <div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// "Apply this optimization to the outermost loops first"</span>
<span class="k">def</span> <span class="nf">outermost</span> <span class="k">=</span> <span class="n">applyToOuterLoopsFirst</span>

<span class="c1">// "Then tile the matrix multiply"</span>
<span class="nf">tile</span><span class="o">(</span><span class="mi">32</span><span class="o">,</span><span class="mi">32</span><span class="o">)</span> <span class="n">after</span> <span class="n">outermost</span>
</code></pre></div></div> <p>But this is still just organized guessing. What if the optimal strategy for one program is terrible for another? Enter e-graphs, stage left.</p> <h2 id="e-graphs-the-keep-everything-revolution">E-graphs: The ‚ÄúKeep Everything‚Äù Revolution</h2> <h3 id="the-big-idea-detectives-corkboard-analogy">The Big Idea (Detective‚Äôs Corkboard Analogy)</h3> <p>Imagine you‚Äôre a detective trying to solve a case. Traditional optimization is like having to choose one lead and throw away all the others. E-graphs [Nelson &amp; Oppen, ‚ÄúFast decision procedures based on congruence closure,‚Äù 1980]? That‚Äôs like having a corkboard where you can pin up EVERY clue and connect them with red string.</p> <p>An <strong>e-graph</strong> (equality graph) is a data structure that stores multiple equivalent expressions simultaneously. When you discover that <code class="language-plaintext highlighter-rouge">x * 2</code> equals <code class="language-plaintext highlighter-rouge">x &lt;&lt; 1</code>, you don‚Äôt replace one with the other - you just connect them with a piece of string saying ‚Äúthese are the same!‚Äù</p> <p>The magic is that e-graphs store all this information incredibly efficiently by sharing common sub-expressions. It‚Äôs like realizing that five different theories all use the same piece of evidence, so you only need to pin it up once.</p> <h3 id="how-e-graphs-actually-work">How E-graphs Actually Work</h3> <p>An e-graph has two main concepts:</p> <p><strong>E-nodes</strong>: These are your actual expressions, like <code class="language-plaintext highlighter-rouge">a + b</code> or <code class="language-plaintext highlighter-rouge">foo(x, y)</code>. Think of them as the individual clues on your corkboard.</p> <p><strong>E-classes</strong>: These are groups of equivalent e-nodes. If <code class="language-plaintext highlighter-rouge">x * 2</code>, <code class="language-plaintext highlighter-rouge">x &lt;&lt; 1</code>, and <code class="language-plaintext highlighter-rouge">x + x</code> are all equivalent, they live in the same e-class. It‚Äôs like having a circle drawn around related clues.</p> <p>The clever bit? E-graphs use a <strong>union-find</strong> data structure (think: extremely efficient way to group things) to keep track of which expressions are equivalent. When you discover a new equivalence, you just union two e-classes together. Boom! Instant optimization propagation.</p> <h3 id="the-e-graph-api-just-four-operations">The E-graph API: Just Four Operations</h3> <p>E-graphs are beautifully simple. You only need four operations:</p> <ol> <li> <strong>add(expression)</strong>: ‚ÄúHey e-graph, remember this expression‚Äù</li> <li> <strong>merge(id1, id2)</strong>: ‚ÄúBTW, these two things are equal‚Äù</li> <li> <strong>find(id)</strong>: ‚ÄúWhat group is this expression in?‚Äù</li> <li> <strong>ematch(pattern)</strong>: ‚ÄúFind me all expressions that look like this‚Äù</li> </ol> <p>That‚Äôs it! With these four operations, you can build incredibly sophisticated optimizers. It‚Äôs like LEGO blocks for compiler writers.</p> <h3 id="e-matching-finding-patterns-in-the-chaos">E-matching: Finding Patterns in the Chaos</h3> <p>E-matching is like playing Where‚Äôs Waldo, but Waldo could be wearing different outfits (equivalent expressions). You give it a pattern like ‚Äúfind all <code class="language-plaintext highlighter-rouge">x + 0</code> expressions‚Äù and it searches through the entire e-graph.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">find_optimization_opportunities</span><span class="p">(</span><span class="n">pattern</span><span class="p">,</span> <span class="n">egraph</span><span class="p">):</span>
    <span class="c1"># "Show me everything that looks like x + 0"
</span>    <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">egraph</span><span class="p">.</span><span class="nf">all_groups</span><span class="p">():</span>
        <span class="k">for</span> <span class="n">expression</span> <span class="ow">in</span> <span class="n">group</span><span class="p">.</span><span class="n">expressions</span><span class="p">:</span>
            <span class="k">if</span> <span class="nf">looks_like</span><span class="p">(</span><span class="n">pattern</span><span class="p">,</span> <span class="n">expression</span><span class="p">):</span>
                <span class="k">yield</span> <span class="sh">"</span><span class="s">Found one!</span><span class="sh">"</span><span class="p">,</span> <span class="n">expression</span>
</code></pre></div></div> <p>The beautiful part? Because the e-graph maintains equivalences, when you find <code class="language-plaintext highlighter-rouge">(a * 2) + 0</code>, you automatically know about <code class="language-plaintext highlighter-rouge">(a &lt;&lt; 1) + 0</code> too!</p> <h3 id="the-magic-non-destructive-rewriting">The Magic: Non-Destructive Rewriting</h3> <p>Here‚Äôs where e-graphs blow your mind. In traditional rewriting:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(a * 2) / 2 ‚Üí a    // Bye bye, original expression!
</code></pre></div></div> <p>In e-graphs:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(a * 2) / 2 ‚âÖ a    // Both exist! They're friends now!
</code></pre></div></div> <p>The process:</p> <ol> <li>Find all instances of your pattern (like <code class="language-plaintext highlighter-rouge">(x * 2) / 2</code>)</li> <li>Calculate what they should become (<code class="language-plaintext highlighter-rouge">x</code>)</li> <li>Don‚Äôt replace! Just merge the e-classes</li> </ol> <p>It‚Äôs like saying ‚Äúthese two expressions are pen pals‚Äù instead of ‚Äúthis expression is dead to me.‚Äù Much more civilized.</p> <h3 id="visual-example-the-old-way-vs-the-e-graph-way">Visual Example: The Old Way vs. The E-graph Way</h3> <pre><code class="language-mermaid">graph TB
    subgraph "Traditional Rewriting"
        A1["(a * 2) / 2"] --&gt;|destroy| A2["(a &lt;&lt; 1) / 2"]
        A2 --&gt;|destroy| A3["a"]
        style A1 fill:#ffcccc,stroke:#ff0000,stroke-width:2px,text-decoration:line-through
        style A2 fill:#ffcccc,stroke:#ff0000,stroke-width:2px,text-decoration:line-through
    end
    
    subgraph "E-graph Approach"
        B1["E-class 1"]
        B1 --&gt; B2["(a * 2) / 2"]
        B1 --&gt; B3["(a &lt;&lt; 1) / 2"]
        B1 --&gt; B4["a"]
        B1 --&gt; B5["..."]]
        style B1 fill:#ccffcc,stroke:#00ff00,stroke-width:2px
    end
</code></pre> <h2 id="equality-saturation-going-full-detective-mode">Equality Saturation: Going Full Detective Mode</h2> <h3 id="the-phase-ordering-problem-why-order-matters">The Phase Ordering Problem (Why Order Matters)</h3> <p>Remember that game where you have to get the fox, chicken, and grain across the river? Traditional optimization is like that, but with 1000 items and no clear rules. This is the dreaded <strong>phase ordering problem</strong> [Tate et al., ‚ÄúEquality saturation: A new approach to optimization,‚Äù POPL 2009].</p> <p>Example with <code class="language-plaintext highlighter-rouge">(a * 2) / 2</code>:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Path 1: Optimize multiplies first
(a * 2) / 2 ‚Üí (a &lt;&lt; 1) / 2 ‚Üí ... ‚Üí ???

Path 2: Apply algebra first  
(a * 2) / 2 ‚Üí a * (2/2) ‚Üí a * 1 ‚Üí a ‚úì
</code></pre></div></div> <p>One path gets you the optimal result, the other gets you stuck. But how do you know which path to take? You don‚Äôt. Until now.</p> <h3 id="equality-saturation-the-try-everything-algorithm">Equality Saturation: The ‚ÄúTry Everything‚Äù Algorithm</h3> <p>Here‚Äôs the brilliant insight: What if we just‚Ä¶ didn‚Äôt choose? What if we applied ALL the optimizations at once and sorted it out later?</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">equality_saturation</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">rules</span><span class="p">):</span>
    <span class="n">egraph</span> <span class="o">=</span> <span class="nf">start_with</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
    
    <span class="k">while</span> <span class="sh">"</span><span class="s">we</span><span class="sh">'</span><span class="s">re still finding new stuff</span><span class="sh">"</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">rule</span> <span class="ow">in</span> <span class="n">rules</span><span class="p">:</span>
            <span class="c1"># Find everywhere this rule could apply
</span>            <span class="n">matches</span> <span class="o">=</span> <span class="n">egraph</span><span class="p">.</span><span class="nf">find_pattern</span><span class="p">(</span><span class="n">rule</span><span class="p">.</span><span class="n">pattern</span><span class="p">)</span>
            
            <span class="k">for</span> <span class="n">match</span> <span class="ow">in</span> <span class="n">matches</span><span class="p">:</span>
                <span class="c1"># Apply the rule (non-destructively!)
</span>                <span class="n">new_expr</span> <span class="o">=</span> <span class="n">rule</span><span class="p">.</span><span class="nf">apply_to</span><span class="p">(</span><span class="n">match</span><span class="p">)</span>
                <span class="n">egraph</span><span class="p">.</span><span class="nf">add</span><span class="p">(</span><span class="n">new_expr</span><span class="p">)</span>
                <span class="n">egraph</span><span class="p">.</span><span class="nf">merge</span><span class="p">(</span><span class="n">match</span><span class="p">,</span> <span class="n">new_expr</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="sh">"</span><span class="s">nothing new was discovered</span><span class="sh">"</span><span class="p">:</span>
            <span class="k">break</span>  <span class="c1"># We're saturated!
</span>    
    <span class="k">return</span> <span class="n">egraph</span><span class="p">.</span><span class="nf">pick_best_expression</span><span class="p">()</span>
</code></pre></div></div> <p><strong>The Algorithm in Plain English:</strong></p> <ol> <li>Start with your expression</li> <li>Apply every possible rule everywhere you can</li> <li>Keep all the results (don‚Äôt throw anything away!)</li> <li>Repeat until you can‚Äôt find any new equivalences</li> <li>Pick the best final result</li> </ol> <p>It‚Äôs like letting a hyperactive monkey loose in an optimization candy store, then picking the best candy it found. Chaotic? Yes. Effective? Absolutely.</p> <h3 id="extraction-picking-the-best-from-the-buffet">Extraction: Picking the Best from the Buffet</h3> <p>Okay, so we‚Äôve applied every optimization known to mankind and our e-graph is stuffed with equivalent expressions. Now what? We need to pick the ‚Äúbest‚Äù one. This is called <strong>extraction</strong>.</p> <p><strong>The Catch:</strong> Remember when I said this was all magical? Well, here‚Äôs the punchline - picking the optimal expression from an e-graph is NP-hard. It‚Äôs like being told the treasure is buried ‚Äúsomewhere on Earth.‚Äù Thanks, very helpful.</p> <p><strong>The Problem:</strong></p> <ul> <li>You need to pick one expression from each e-class</li> <li>But the choices are interdependent (picking <code class="language-plaintext highlighter-rouge">a + b</code> in one place might make <code class="language-plaintext highlighter-rouge">b + a</code> better elsewhere)</li> <li>Finding the global optimum is computationally brutal</li> </ul> <p>But don‚Äôt worry! We have tricks up our sleeve‚Ä¶</p> <h4 id="approach-1-the-mathematicians-solution-ilp">Approach 1: The Mathematician‚Äôs Solution (ILP)</h4> <p>You can formulate extraction as an Integer Linear Programming problem. Basically, you‚Äôre asking a very expensive solver to find the optimal solution.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Minimize: total cost of selected expressions
Subject to:
  - Pick at least one thing from each e-class
  - If you pick an expression, pick all its children
  - Don't create cycles (no circular reasoning!)
</code></pre></div></div> <p><strong>Pro:</strong> Guaranteed optimal solution! <strong>Con:</strong> Might take until the heat death of the universe for large programs.</p> <h4 id="approach-2-the-graph-theorists-dream-dynamic-programming">Approach 2: The Graph Theorist‚Äôs Dream (Dynamic Programming)</h4> <p>If your e-graph has nice structure (technically: low treewidth), you can use dynamic programming. It‚Äôs like solving a puzzle by breaking it into smaller, manageable pieces.</p> <p><strong>The Idea:</strong></p> <ul> <li>Decompose the e-graph into a tree of ‚Äúbags‚Äù</li> <li>Solve each bag independently</li> <li>Combine solutions cleverly</li> </ul> <p><strong>When It Works:</strong> Great for e-graphs that look like trees with a few extra edges <strong>When It Doesn‚Äôt:</strong> Not so great for e-graphs that look like hairballs</p> <h4 id="approach-3-the-engineers-good-enough-heuristics">Approach 3: The Engineer‚Äôs ‚ÄúGood Enough‚Äù (Heuristics)</h4> <p>Most real systems say ‚Äúperfect is the enemy of good‚Äù and use heuristics:</p> <p><strong>Bottom-up Greedy:</strong> Start from the leaves, pick the cheapest option at each level</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">extract_greedy</span><span class="p">(</span><span class="n">eclass</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">eclass</span><span class="p">.</span><span class="nf">is_leaf</span><span class="p">():</span>
        <span class="k">return</span> <span class="nf">cheapest_option</span><span class="p">(</span><span class="n">eclass</span><span class="p">)</span>
    
    <span class="c1"># Try each option with greedy children
</span>    <span class="n">best</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="k">for</span> <span class="n">expr</span> <span class="ow">in</span> <span class="n">eclass</span><span class="p">:</span>
        <span class="n">cost</span> <span class="o">=</span> <span class="n">expr</span><span class="p">.</span><span class="n">cost</span> <span class="o">+</span> <span class="nf">sum</span><span class="p">(</span><span class="nf">extract_greedy</span><span class="p">(</span><span class="n">child</span><span class="p">)</span> <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">expr</span><span class="p">.</span><span class="n">children</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">cost</span> <span class="o">&lt;</span> <span class="n">best</span><span class="p">.</span><span class="n">cost</span><span class="p">:</span>
            <span class="n">best</span> <span class="o">=</span> <span class="n">expr</span>
    <span class="k">return</span> <span class="n">best</span>
</code></pre></div></div> <p><strong>Pool Extraction:</strong> The ‚Äúthrow spaghetti at the wall‚Äù approach:</p> <ol> <li>Generate 100 different extractions using various strategies</li> <li>Add some random ones for spice</li> <li>Evaluate them all</li> <li>Pick the winner</li> </ol> <p>Surprisingly effective! Like how a room full of monkeys with typewriters occasionally produces Shakespeare.</p> <h2 id="enter-egg-the-game-changer-">Enter egg: The Game Changer ü•ö</h2> <p>For years, e-graphs were like fusion power - always 10 years away from being practical. They were slow, hard to implement, and each one was a custom job. Then came <strong>egg</strong> <a href="https://arxiv.org/abs/2004.03082" rel="external nofollow noopener" target="_blank">Willsey et al., ‚Äúegg: Fast and extensible equality saturation,‚Äù POPL 2021</a> (e-graphs good!).</p> <h3 id="why-egg-changed-everything">Why egg Changed Everything</h3> <p>Before egg: ‚ÄúI‚Äôll spend 6 months implementing an e-graph for my specific problem‚Äù After egg: ‚ÄúI‚Äôll have a working optimizer by lunch‚Äù</p> <p><strong>The Secret Sauce:</strong></p> <ol> <li> <p><strong>Rebuilding Magic:</strong> Instead of constantly maintaining the e-graph (expensive!), egg says ‚Äúlet‚Äôs batch everything and fix it periodically.‚Äù It‚Äôs like cleaning your room once a week instead of after every sock.</p> </li> <li> <strong>E-class Analysis:</strong> This is the killer feature. You can attach arbitrary data to e-classes. Is this expression a constant? What‚Äôs its type? Does it have side effects? Now your rewrites can be smart: <div class="language-rust highlighter-rouge"> <div class="highlight"><pre class="highlight"><code><span class="c1">// Only optimize division if we know it's not divide-by-zero!</span>
<span class="nd">rewrite!</span><span class="p">(</span><span class="s">"div-safe"</span><span class="p">;</span> <span class="s">"(/ ?x ?y)"</span> <span class="k">=&gt;</span> <span class="s">"?x"</span> <span class="k">if</span> <span class="nf">is_one</span><span class="p">(</span><span class="o">?</span><span class="n">y</span><span class="p">))</span>
</code></pre></div> </div> </li> <li> <strong>It‚Äôs FAST:</strong> 20√ó faster than previous implementations. That‚Äôs the difference between waiting minutes and waiting days.</li> </ol> <h3 id="e-class-analysis-making-your-e-graph-smart">E-class Analysis: Making Your E-graph Smart</h3> <p>Remember how I said e-graphs keep all equivalent expressions? Well, what if each group could also remember facts about itself? That‚Äôs e-class analysis.</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// "Hey e-graph, remember that this expression is always positive"</span>
<span class="c1">// "This one is a constant with value 42"</span>
<span class="c1">// "This expression has no side effects"</span>
</code></pre></div></div> <p><strong>Real Examples:</strong></p> <p><strong>Constant Folding:</strong></p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">analysis</span><span class="p">:</span> <span class="n">ConstantFold</span>
<span class="n">e</span><span class="o">-</span><span class="n">class</span><span class="p">:</span> <span class="p">{</span><span class="mi">2</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">}</span>
<span class="n">analysis</span> <span class="n">says</span><span class="p">:</span> <span class="s">"BTW, this whole e-class equals 4"</span>
</code></pre></div></div> <p><strong>Range Analysis:</strong></p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">analysis</span><span class="p">:</span> <span class="n">IntervalAnalysis</span>  
<span class="n">e</span><span class="o">-</span><span class="n">class</span><span class="p">:</span> <span class="p">{</span><span class="n">x</span><span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="nf">pow</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="mi">2</span><span class="p">)}</span>
<span class="n">analysis</span> <span class="n">says</span><span class="p">:</span> <span class="s">"This is always ‚â• 0"</span>
<span class="c1">// Now you can optimize sqrt(x*x) ‚Üí abs(x)!</span>
</code></pre></div></div> <p>It‚Äôs like each e-class has a personal assistant keeping track of important facts.</p> <h3 id="conditional-rewrites-smart-optimizations">Conditional Rewrites: Smart Optimizations</h3> <p>With e-class analysis, your rewrites can be conditional. It‚Äôs like having optimization rules that say ‚Äúonly do this if you‚Äôre sure it‚Äôs safe.‚Äù</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Old way: "Always optimize x/y to something"</span>
<span class="c1">// New way: "Only optimize x/y if y isn't zero"</span>

<span class="nd">rewrite!</span><span class="p">(</span><span class="s">"safe-div"</span><span class="p">;</span> <span class="s">"(/ ?x ?y)"</span> <span class="k">=&gt;</span> <span class="s">"?x"</span> 
  <span class="k">if</span> <span class="nf">is_one</span><span class="p">(</span><span class="o">?</span><span class="n">y</span><span class="p">));</span>  <span class="c1">// Only if y = 1</span>

<span class="nd">rewrite!</span><span class="p">(</span><span class="s">"pythagoras"</span><span class="p">;</span> <span class="s">"(sqrt (+ (* ?x ?x) (* ?y ?y)))"</span> <span class="k">=&gt;</span> <span class="s">"(abs ?z)"</span>
  <span class="k">if</span> <span class="nf">is_complex</span><span class="p">(</span><span class="o">?</span><span class="n">z</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">?</span><span class="n">z</span> <span class="o">=</span> <span class="o">?</span><span class="n">x</span> <span class="o">+</span> <span class="o">?</span><span class="n">y</span><span class="o">*</span><span class="n">i</span><span class="p">);</span>  <span class="c1">// Complex number optimization!</span>
</code></pre></div></div> <p><strong>My Favorite Examples:</strong></p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Strength reduction, but only for powers of 2</span>
<span class="nd">rewrite!</span><span class="p">(</span><span class="s">"mul-to-shift"</span><span class="p">;</span> <span class="s">"(* ?x ?c)"</span> <span class="k">=&gt;</span> <span class="s">"(&lt;&lt; ?x ?n)"</span>
  <span class="k">if</span> <span class="nf">is_power_of_two</span><span class="p">(</span><span class="o">?</span><span class="n">c</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">?</span><span class="n">n</span> <span class="o">=</span> <span class="nf">log2</span><span class="p">(</span><span class="o">?</span><span class="n">c</span><span class="p">));</span>

<span class="c1">// Remove assertions that we can prove are true</span>
<span class="nd">rewrite!</span><span class="p">(</span><span class="s">"remove-true-assert"</span><span class="p">;</span> <span class="s">"(assert ?cond ?expr)"</span> <span class="k">=&gt;</span> <span class="s">"?expr"</span>
  <span class="k">if</span> <span class="nf">can_prove</span><span class="p">(</span><span class="o">?</span><span class="n">cond</span><span class="p">));</span>
</code></pre></div></div> <p>It‚Äôs optimization with a brain!</p> <h2 id="quick-comparison-traditional-vs-e-graphs">Quick Comparison: Traditional vs E-graphs</h2> <p>Let me break it down for you:</p> <table> <thead> <tr> <th>Feature</th> <th>Traditional Term Rewriting</th> <th>E-graphs + Equality Saturation</th> </tr> </thead> <tbody> <tr> <td><strong>Core Idea</strong></td> <td>Apply one rule at a time, destroy the original</td> <td>Keep everything, explore all paths</td> </tr> <tr> <td><strong>Analogy</strong></td> <td>Following a strict recipe</td> <td>Detective‚Äôs corkboard with red string</td> </tr> <tr> <td><strong>Phase Ordering</strong></td> <td>‚ÄúPick the right order or suffer‚Äù</td> <td>‚ÄúWhat‚Äôs phase ordering?‚Äù üòé</td> </tr> <tr> <td><strong>Optimization Quality</strong></td> <td>Depends on rule order</td> <td>Finds optimal (given enough time)</td> </tr> <tr> <td><strong>Speed</strong></td> <td>Fast per rule</td> <td>Slower but does everything at once</td> </tr> <tr> <td><strong>Memory Usage</strong></td> <td>Minimal</td> <td>‚ÄúRAM is cheap, right?‚Äù</td> </tr> <tr> <td><strong>When to Use</strong></td> <td>Simple, local optimizations</td> <td>Complex, whole-program optimization</td> </tr> <tr> <td><strong>Main Weakness</strong></td> <td>Gets stuck in local optima</td> <td>Extraction is NP-hard</td> </tr> </tbody> </table> <h2 id="real-world-success-stories">Real-World Success Stories</h2> <h3 id="herbie-making-floating-point-math-not-suck">Herbie: Making Floating-Point Math Not Suck</h3> <p>Floating-point arithmetic is where good programmers go to cry. You write <code class="language-plaintext highlighter-rouge">sqrt(x+1) - sqrt(x)</code> and for large x, you get‚Ä¶ 0? Thanks, floating point! Enter Herbie <a href="https://herbie.uwplse.org/pldi15-paper.pdf" rel="external nofollow noopener" target="_blank">Panchekha et al., ‚ÄúAutomatically improving accuracy for floating point expressions,‚Äù PLDI 2015</a>.</p> <p><strong>The Herbie Magic:</strong> Herbie uses egg to find mathematically equivalent expressions that don‚Äôt suffer from catastrophic cancellation:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Original: sqrt(x+1) - sqrt(x)
Problem: When x is large, both sqrts are nearly equal ‚Üí precision loss

Herbie finds: 1/(sqrt(x+1) + sqrt(x))
Why better: No subtraction of nearly-equal numbers!
</code></pre></div></div> <p><strong>The Punchline:</strong></p> <ul> <li>3000√ó faster than the old Herbie (not a typo!)</li> <li>Accuracy improved from 53% to 99.7%</li> <li>Turns numerical analysis PhD problems into ‚Äúpush button, get answer‚Äù</li> </ul> <p>I‚Äôve used Herbie on real code. It‚Äôs like having a numerical analysis expert on speed dial.</p> <h3 id="hardware-design-making-chips-cheaper">Hardware Design: Making Chips Cheaper</h3> <p><strong>The Problem:</strong> You‚Äôre designing a chip. Every gate costs money. Every nanosecond of delay costs performance.</p> <p><strong>E-graphs to the Rescue:</strong></p> <div class="language-verilog highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Original hardware:</span>
<span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="n">y</span><span class="p">)</span> <span class="o">?</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">:</span> <span class="mi">0</span>

<span class="c1">// E-graph finds:</span>
<span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="n">y</span><span class="p">)</span> <span class="o">?</span> <span class="mi">2</span><span class="o">*</span><span class="n">y</span> <span class="o">:</span> <span class="mi">0</span>  <span class="c1">// One less adder input!</span>
</code></pre></div></div> <p><strong>Real Example from E-Syn:</strong> They used egg + machine learning to optimize hardware designs:</p> <ol> <li>E-graph explores equivalent circuits</li> <li>ML model predicts area/delay without synthesis</li> <li>Pick the best one</li> </ol> <p>Result? 30% smaller circuits with same functionality. That‚Äôs millions of dollars saved in chip production!</p> <h3 id="compiler-magic-cranelift-and-friends">Compiler Magic: Cranelift and Friends</h3> <p><strong>Cranelift √¶graphs:</strong> WebAssembly‚Äôs compiler using e-graphs:</p> <ul> <li>Problem: How do you apply e-graphs when you have control flow?</li> <li>Solution: ‚ÄúLet‚Äôs just e-graph the straight-line code and keep the control flow separate‚Äù</li> <li>Result: Fast compilation with good optimization</li> </ul> <p><strong>Diospyros</strong> <a href="https://dl.acm.org/doi/10.1145/3445814.3446707" rel="external nofollow noopener" target="_blank">VanHattum et al., ‚ÄúVectorization for digital signal processors via equality saturation,‚Äù ASPLOS 2021</a>: Vectorization on steroids:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Original loop:
for i in 0..n:
    c[i] = sqrt(a[i]) + b[i]

// Diospyros finds the exact vector instructions:
vec_sqrt_add(a, b)  // One instruction instead of n*2!
</code></pre></div></div> <p><strong>The Catch:</strong> E-graphs can explode for large programs. Optimizing 8√ó8√ó8 matrix multiply? Hope you have RAM to spare!</p> <p><strong>Isaria‚Äôs Innovation:</strong> ‚ÄúWhat if we automatically learned rewrite rules from the instruction manual?‚Äù</p> <ul> <li>Feed it ISA documentation</li> <li>It generates rewrite rules automatically</li> <li>Your compiler understands new instructions without manual work</li> </ul> <h2 id="egglog-the-next-generation-">Egglog: The Next Generation ü§Ø</h2> <h3 id="what-if-e-graphs-could-think">What if E-graphs Could Think?</h3> <p>Egglog <a href="https://arxiv.org/abs/2304.04332" rel="external nofollow noopener" target="_blank">Zhang et al., ‚ÄúBetter Together: Unifying Datalog and Equality Saturation,‚Äù PLDI 2023</a> is what happens when someone looks at e-graphs and says ‚Äúthis is cool, but what if we added Prolog?‚Äù It‚Äôs e-graphs meets logic programming, and it‚Äôs wild.</p> <p><strong>The Big Idea:</strong> Instead of just tracking equivalences, what if we could reason about relationships?</p> <div class="language-prolog highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">//</span> <span class="nv">Traditional</span> <span class="ss">e</span><span class="o">-</span><span class="ss">graph</span><span class="o">:</span> <span class="s2">"These expressions are equal"</span>
<span class="o">//</span> <span class="nv">Egglog</span><span class="o">:</span> <span class="s2">"These expressions are equal AND here's why AND here's what else we can deduce"</span>
</code></pre></div></div> <p><strong>Example That Blew My Mind:</strong></p> <pre><code class="language-datalog">(datatype Math
  (Num i64)
  (Add Math Math)
  (Mul Math Math))

// Normal rewrites
(rewrite (Add (Num 0) x) x)
(rewrite (Mul (Num 1) x) x)

// But also relations!
(relation is-positive (Math))
(rule ((= x (Mul y y))) ((is-positive x)))  // Squares are positive

// Now optimizations can use reasoning
(rewrite (sqrt (Mul x x)) x 
  if (is-positive x))  // Safe because we proved it!
</code></pre> <h3 id="egglog-superpowers">Egglog Superpowers</h3> <p><strong>Program Analysis on Steroids:</strong></p> <pre><code class="language-datalog">// "Which basic blocks can reach the exit?"
(relation reaches-exit (BasicBlock))
(rule ((is-exit ?block)) ((reaches-exit ?block)))
(rule ((edge ?from ?to) (reaches-exit ?to)) 
      ((reaches-exit ?from)))

// Now optimize: "Remove code that can't reach exit!"
</code></pre> <p><strong>Incremental Everything:</strong></p> <ul> <li>Your program changed? Egglog updates just what‚Äôs needed</li> <li>No more ‚Äúrebuild the world‚Äù after every edit</li> <li>It‚Äôs like Git for your optimizer‚Äôs brain</li> </ul> <p><strong>The Killer App I‚Äôm Waiting For:</strong> Security analysis + optimization in one pass. ‚ÄúThis is equivalent AND secure AND fast.‚Äù</p> <h2 id="the-future-where-this-is-all-going">The Future: Where This is All Going</h2> <h3 id="the-scalability-wall">The Scalability Wall</h3> <p>Current challenge: E-graphs get HUGE for big programs. Like, ‚Äúeat all your RAM and ask for seconds‚Äù huge.</p> <h3 id="ml--e-graphs--Ô∏è">ML + E-graphs = ‚ù§Ô∏è</h3> <p>The hot new thing: Teaching e-graphs to be smarter with machine learning.</p> <p><strong>Learning What‚Äôs Important:</strong></p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Old way: Try everything!
# New way: ML says "try this first, it usually works"
</span><span class="n">model</span><span class="p">.</span><span class="nf">predict_best_rewrite</span><span class="p">(</span><span class="n">expression</span><span class="p">)</span>
</code></pre></div></div> <p>There are some works on EGRAPH 2025 for this topic.</p> <h3 id="the-theory-gap">The Theory Gap</h3> <p>We‚Äôre using e-graphs everywhere, but the theory is playing catch-up:</p> <ul> <li>When exactly does equality saturation terminate?</li> <li>Can we prove extraction finds the optimal solution?</li> <li>What are the complexity bounds?</li> </ul> <p>It‚Äôs like we invented cars before understanding thermodynamics. It works, but we‚Äôre not always sure why!</p> <h2 id="wrapping-up-why-this-matters">Wrapping Up: Why This Matters</h2> <h3 id="the-journey-so-far">The Journey So Far</h3> <p>We‚Äôve come a long way from ‚Äúapply rules and hope for the best‚Äù:</p> <ol> <li> <strong>Term Rewriting</strong>: The old way. One rule at a time, fingers crossed.</li> <li> <strong>E-graphs</strong>: Keep everything! Build a map of all possibilities.</li> <li> <strong>Equality Saturation</strong>: Explore everything! Find the best path.</li> <li> <strong>egg</strong>: Make it fast and usable for mortals.</li> <li> <strong>Egglog</strong>: Add reasoning and logic to the mix.</li> </ol> <h3 id="why-you-should-care">Why You Should Care</h3> <p>E-graphs aren‚Äôt just another optimization technique. They‚Äôre a fundamentally different way of thinking about program transformation:</p> <p><strong>Before</strong>: ‚ÄúWhat‚Äôs the right order to apply optimizations?‚Äù <strong>After</strong>: ‚ÄúWhat if we didn‚Äôt have to choose?‚Äù</p> <p>It‚Äôs like the difference between taking one photo and hoping it‚Äôs good vs. taking 1000 photos and picking the best one. Except the camera (egg) is really fast now.</p> <h3 id="my-take">My Take</h3> <p>After working with e-graphs, going back to traditional optimization feels like coding with one hand tied behind my back. Yes, extraction is NP-hard. Yes, e-graphs can explode in size. But the ability to explore the entire optimization space and <em>know</em> you‚Äôre not missing opportunities? That‚Äôs powerful.</p> <h3 id="the-bottom-line">The Bottom Line</h3> <p>E-graphs and equality saturation represent a paradigm shift in how we think about optimization. By keeping all possibilities alive and exploring them simultaneously, we‚Äôve opened doors that were previously locked by the phase ordering problem.</p> <p>Is it perfect? No. Is it the future? I think so.</p> </div> </article> </div> </div> </div> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> ¬© Copyright 2025 Youwei Xiao. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. Last updated: July 06, 2025. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js" integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin="anonymous"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/mermaid@10.7.0/dist/mermaid.min.js" integrity="sha256-TtLOdUA8mstPoO6sGvHIGx2ceXrrX4KgIItO06XOn8A=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/d3@7.8.5/dist/d3.min.js" integrity="sha256-1rA678n2xEx7x4cTZ5x4wpUCj6kUMZEZ5cxLSVSFWxw=" crossorigin="anonymous"></script> <script>let mermaidTheme=determineComputedTheme();document.addEventListener("readystatechange",()=>{"complete"===document.readyState&&(document.querySelectorAll("pre>code.language-mermaid").forEach(e=>{const t=e.textContent,d=e.parentElement;d.classList.add("unloaded");let a=document.createElement("pre");a.classList.add("mermaid");const n=document.createTextNode(t);a.appendChild(n),d.after(a)}),mermaid.initialize({theme:mermaidTheme}),"undefined"!=typeof d3&&window.addEventListener("load",function(){d3.selectAll(".mermaid svg").each(function(){var e=d3.select(this);e.html("<g>"+e.html()+"</g>");var t=e.select("g"),d=d3.zoom().on("zoom",function(e){t.attr("transform",e.transform)});e.call(d)})}))});</script> <script defer src="https://tikzjax.com/v1/tikzjax.js" integrity="sha256-+1qyucCXRZJrCg3lm3KxRt/7WXaYhBid4/1XJRHGB1E=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script defer src="/assets/js/bootstrap-toc.min.js?c82ff4de8b0955d6ff14f5b05eed7eb6"></script> <script defer src="https://cdn.jsdelivr.net/npm/bootstrap-table@1.22.4/dist/bootstrap-table.min.js" integrity="sha256-4rppopQE9POKfukn2kEvhJ9Um25Cf6+IDVkARD0xh78=" crossorigin="anonymous"></script> <script src="/assets/js/no_defer.js?2781658a0a2b13ed609542042a859126"></script> <script defer src="/assets/js/common.js?e0514a05c5c95ac1a93a8dfd5249b92e"></script> <script defer src="/assets/js/copy_code.js?12775fdf7f95e901d7119054556e495f" type="text/javascript"></script> <script defer src="/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script type="text/javascript">window.MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["\\[","\\]"]],processEscapes:!0,processEnvironments:!0}};</script> <script type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script> <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/pseudocode@2.4.1/build/pseudocode.min.js" integrity="sha256-aVkDxqyzrB+ExUsOY9PdyelkDhn/DfrjWu08aVpqNlo=" crossorigin="anonymous"></script> <script>document.addEventListener("readystatechange",()=>{"complete"===document.readyState&&document.querySelectorAll("pre>code.language-pseudocode").forEach(e=>{const t=e.textContent,d=e.parentElement.parentElement;let n=document.createElement("pre");n.classList.add("pseudocode");const o=document.createTextNode(t);n.appendChild(o),d.appendChild(n),d.removeChild(e.parentElement),pseudocode.renderElement(n)})});</script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> <script src="/assets/js/tabs.min.js?b8748955e1076bbe0dabcf28f2549fdc"></script> <script src="/assets/js/vanilla-back-to-top.min.js?f40d453793ff4f64e238e420181a1d17"></script> <script>addBackToTop();</script> <script type="module" src="/assets/js/search/ninja-keys.min.js?a3446f084dcaecc5f75aa1757d087dcf"></script> <ninja-keys hidebreadcrumbs noautoloadmdicons placeholder="Type to start searching"></ninja-keys> <script>let searchTheme=determineComputedTheme();const ninjaKeys=document.querySelector("ninja-keys");"dark"===searchTheme?ninjaKeys.classList.add("dark"):ninjaKeys.classList.remove("dark");const openSearchModal=()=>{const e=$("#navbarNav");e.hasClass("show")&&e.collapse("hide"),ninjaKeys.open()};</script> <script>const ninja=document.querySelector("ninja-keys");ninja.data=[{id:"nav-about",title:"About",section:"Navigation",handler:()=>{window.location.href="/"}},{id:"nav-blog",title:"Blog",description:"",section:"Navigation",handler:()=>{window.location.href="/blog/"}},{id:"post-llm-in-very-daily-life-enjoy-claude-code-and-gemini-cli-39-s-super-power",title:"LLM in very daily life? Enjoy Claude Code and Gemini-cli&#39;s super power!",description:"Share an expierence of using LLM agents for life (rather than for work)",section:"Posts",handler:()=>{window.location.href="/blog/2025/LLM-in-life/"}},{id:"post-what-if-you-never-had-to-choose-a-journey-into-e-graphs-and-equality-saturation",title:"What if You Never Had to Choose? A Journey into E-graphs and Equality...",description:"How e-graphs turn the optimizer&#39;s dilemma into a solved problem by keeping all the good ideas at once, featuring real examples, bad jokes, and the magic of egg",section:"Posts",handler:()=>{window.location.href="/blog/2025/egg-things/"}},{id:"post-glancing-at-the-simulation-landscape",title:"Glancing at the Simulation Landscape",description:"Survey on simulation tools for computer architecture research",section:"Posts",handler:()=>{window.location.href="/blog/2025/sim/"}},{id:"socials-email",title:"Send email",section:"Socials",handler:()=>{window.open("mailto:%73%68%61%6C%6C%77%65%78%69%61%6F@%67%6D%61%69%6C.%63%6F%6D","_blank")}},{id:"socials-orcid",title:"ORCID",section:"Socials",handler:()=>{window.open("https://orcid.org/0000-0002-3636-3685","_blank")}},{id:"socials-github",title:"GitHub",section:"Socials",handler:()=>{window.open("https://github.com/uv-xiao","_blank")}},{id:"socials-linkedin",title:"LinkedIn",section:"Socials",handler:()=>{window.open("https://www.linkedin.com/in/youwei-xiao-070113282","_blank")}},{id:"socials-x",title:"X",description:"Twitter",section:"Socials",handler:()=>{window.open("https://twitter.com/youwei_xiao","_blank")}},{id:"socials-dblp",title:"DBLP",section:"Socials",handler:()=>{window.open("https://dblp.org/pid/336/0763.html","_blank")}},{id:"socials-rss",title:"RSS Feed",section:"Socials",handler:()=>{window.open("/feed.xml","_blank")}},{id:"light-theme",title:"Change theme to light",description:"Change the theme of the site to Light",section:"Theme",handler:()=>{setThemeSetting("light")}},{id:"dark-theme",title:"Change theme to dark",description:"Change the theme of the site to Dark",section:"Theme",handler:()=>{setThemeSetting("dark")}},{id:"system-theme",title:"Use system default theme",description:"Change the theme of the site to System Default",section:"Theme",handler:()=>{setThemeSetting("system")}}];</script> <script src="/assets/js/shortcut-key.js?6f508d74becd347268a7f822bca7309d"></script> </body> </html>