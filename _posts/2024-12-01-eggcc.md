---
layout: post
title: Look into eggcc
date: 2024-12-01 00:00:00
description:
tags:
categories:
tabs: true
thumbnail:
mermaid:
  enabled: true
  zoomable: true
toc:
  beginning: true
  # sidebar: left
pretty_table: true
tikzjax: true
pseudocode: true
---

# Eggcc

> I'm trying to use e-graph/eqsat/extract/... to do some compiler-involved stuff. The [eggcc](https://github.com/egraphs-good/eggcc) is a good starting point. And here is my note of it.
{: .block-tip}

## About

[eggcc](https://github.com/egraphs-good/eggcc) compiles [bril](https://github.com/uwplse/bril) to LLVMIR/cranelift. It is mainly hosted by UW PLSE lab (I guess, since the active contributors, including Oliver Flatt, Anjali Pal, and Yihong Zhang, are from the lab). The project is still under heavy development, and lacks open documentation. I found it very inspiring as a rewrite-based, more specifically [egglog](https://github.com/egraphs-good/egglog)-based compiler. So here is my note of it.

Related work:

- [jlm](https://github.com/phate/jlm): `RVSDG`-based compiler: `llvmir -> RVSDG -> llvmir/mlir/circt`;
- [optir](https://github.com/jameysharp/optir/):  proof-of-concept `RVSDG`-based compiler, use [egg](https://github.com/egraphs-good/egg) for optimization;


## Have the first try

> words to my colleague:
> please use my fork of eggcc, which is [uv-xiao/eggcc](https://github.com/uv-xiao/eggcc).
{: .block-tip}

Follow [eggcc's README](https://github.com/egraphs-good/eggcc)'s instruction for installation (which should be fine :smiley:), then run:

```
cargo run -- --debug-dir ./temp --run-mode optimize  <bril, e.g. ./tests/passing/small/loop_if.bril> 
```

Then, [eggcc](https://github.com/egraphs-good/eggcc) will generate the `temp` directory, holding some visualization files for `rvsdg`, `cfg`, and `dag`. And the optimized `bril` code will be printed to stdout.


~~Also, you can run (after some npm setup):~~

```
bash infra/localnightly.sh <bril file or directory>
cd nightly/output && python3 -m http.server
```

~~to get a local server for report and visualization of `eggcc`'s runs.~~

> seems not useful for us
{: .block-tip}

## How to develop

### Setup local egglog demo

After clone eggcc (maybe from [my fork](https://github.com/uv-xiao/eggcc)), you'd better also clone the [egglog](https://github.com/egraphs-good/egglog) repo and checkout to the commit used by eggcc.

```bash
git clone git@github.com:egraphs-good/egglog.git
cd egglog
git checkout 246b195 # make sure the commit is the same as eggcc!
```

Then, you can start the egglog web-demo locally (you may need some proxy setting for fast installation):

```bash
cargo install cargo-watch wasm-pack
make serve # it can be slow for the first time
# if make serve failed, tab Ctrl-c to stop, and run `make serve` again
```
Then you can open the `http://localhost:8080/` in your browser.

You can also install `egglog` locally:
```bash
# under egglog directory
cargo install --path . --root <path-to-install, like $HOME/.local>
```
After, you can run `egglog --to-dot <path-to-egglog-program>` to get the dot file.

### Install vscode extension

named `egglog-language`

### Add new rulesets

Take a look at the `peepholes` ruleset in `dag_in_context/src/optimizations/peepholes.rs` and `dag_in_context/src/optimizations/peepholes.egg` for example;

In the `arith_rewrites` test function, it first create `expr: Rc<Expr>`, representing `(0 + x + 0 + 1 + 2 + y * 1)`. The expected output `expected: Rc<Expr>` is `(x + 3 + y)`. And the test calls `egglog_test()`, which includes:

```
; eggcc prologue, thousands of lines
(let expr_ {expr}) ; build expr_ from expr
; run eggcc schedule
(check (= expr_ {expected})) ; check if the expected output is derived
```

Then, you can run the test:

```
cargo test -p dag_in_context -- optimizations::peepholes::arith_rewrites --exact --show-output
```
where `optimizations::peepholes::arith_rewrites` is the path to the test function. `--exact` is used to match the exact function name, and `--show-output` is used to show the output of the test.

The stdout will contain:
```
Writing egglog test to <path-to-eggcc>/dag_in_context/temp/egglog_test.egg
```
which contains thousands of lines.

In `dag_in_context/src/lib.rs`, you can check the `egglog_test_internal` to see how the egglog program is generated:
```
  let program = format!(
    ";Here is the <PROLOGUE>\n{}\n\n;Here is the <BUILD>\n{build}\n\n;Here is the <SCHEDULE>\n{}\n\n;Here is the <CHECK>\n{check}\n",
    reduce_redundant_nlines(prologue()),
    reduce_redundant_nlines(
      parallel_schedule()
        .iter()
        .map(|pass| pass.egglog_schedule().to_string())
        .collect::<Vec<String>>()
        .join("\n")
    ),
  );
```

And you can search for `;Here is the <BUILD>` to find the original `expr`, and `;Here is the <CHECK>` to find the expected output.

> The `interpret` feature of eggcc is also useful for debugging. Currently, I've not used it. This is a TODO.
{: .block-tip}

Now, you can paste the egglog program to the local egglog demo, and see if the expected output is derived.

You can use the `Slidemode` to inspect the egglog execution step by step.

#### Make it more accessible

Currently, the egglog program is not accessible. IT'S TOO LONG! And the `schedule`s do too much things.
```
prologue lines: 4703
schedule lines: 497
```
And the produced graphviz file contains too many nodes and edges (2362 lines).

So, we may make them simpler.

1. apply `debug-deletes` ruleset for simplified visualization;
  ```
  (run-schedule debug-deletes) ; after <CHECK>
  ```
  for the `peepholes::arith_rewrites` test, the dot file lines reduce to 1743 lines, much more readable.
2. ...

> TODO: simplify prologue and schedule.
{: .block-tip}





## How it works

Main loop: in `src/utils.rs`, `Run::optimize_bril`:

```rust
fn optimize_bril(program: &Program, config: &EggccConfig) -> Result<Program, EggCCError> {
  let rvsdg = Optimizer::program_to_rvsdg(program)?;
  let (dag, mut cache) = rvsdg.to_dag_encoding(true);
  let optimized =
      dag_in_context::optimize(&dag, &mut cache, config).map_err(EggCCError::EggLog)?;
  let rvsdg2 = dag_to_rvsdg(&optimized);
  let cfg = rvsdg2.to_cfg();
  let bril = cfg.to_bril();
  let bril = canonicalize_bril(&bril);
  Ok(bril)
}
```

### RVSDG

In `src/rvsdg/mod.rs`:

| struct/enum | description                                        | members                      |
| ----------- | -------------------------------------------------- | ---------------------------- |
| `BasicExpr` | prim op, function call, const, effect (mem, print) | operands: `Vec<Op>`          |
| `Operand`   | region arg, region output                          | i-th arg/output, region `Id` |
| `RvsdgBody` | basic, if (0/1), gamma (switch), theta (do-while)  | holding `Operand`s           |

`rvsdg` format is imagelike, exprs and bodies are nodes, operands are edges.

For example, [min.bril](https://github.com/egraphs-good/eggcc/blob/main/tests/passing/small/min.bril):
```
# ARGS: 20 30
@main(x: int, y: int) {
  cmp: bool = lt x y;
  res: int = id y;
  br cmp .then .else;
  .then:
    res: int = id x;
  .else:
  .done:
    print res;
}
```
corresponds to two rvsdgs: 

<div class="row mt-3">
    <div class="col-sm mt-3 mt-md-0">
        {% include figure.liquid loading="eager" path="assets/img/in_posts/2024-12-01-eggcc-rvsdg.png" class="img-fluid rounded z-depth-1" zoomable=true %}
    </div>
    <div class="col-sm mt-3 mt-md-0">
    {% include figure.liquid loading="eager" path="assets/img/in_posts/2024-12-01-eggcc-rvsdg-optmized.png" class="img-fluid rounded z-depth-1" zoomable=true %}
    </div>
</div>
<div class="caption">
  unoptimized/optimized rvsdg
</div>



### DAG

`rvsdg->dag`: in `src/rvsdg/to_dag.rs`, `RvsdgProgram::to_dag_encoding`

`dag`: in `dag_in_context/schema.rs`

The `dag` format is a graph of expressions with contexts:

| struct/enum | description | members |
| --- | --- | --- |
| `TreeProgram` | program | entry, functions |
| `Expr` | expression, including func, loop, expr, ... | `RcExpr` as operands and results|
| `RcExpr`| expression as data | `Rc<Expr>` |
| `Assumption` | context, in-loop, in-if, ... | directly bound to consts, and args |

> For more details about `Assumption`, see `ASSUME` nodes in "Automating Constraint-Aware Datapath Optimization using E-Graphs. DAC 2023, doi: 10.1109/DAC56929.2023.0247797".

[min.bril](https://github.com/egraphs-good/eggcc/blob/main/tests/passing/small/min.bril)'s unoptimized rvsdg is converted to:

<div class="row mt-1">
    <div class="col-sm mt-1 mt-md-0">
        {% include figure.liquid loading="eager" path="assets/img/in_posts/2024-12-01-eggcc-dag.png" class="img-fluid rounded z-depth-1" zoomable=true %}
    </div>
</div>
<div class="caption">
  unoptimized dag
</div>


### Egglog

`dag->egglog`: in `dag_in_context/to_egglog.rs`, `TreeToEgglog`:
```rust
pub(crate) struct TreeToEgglog {
    pub termdag: TermDag,
    // Cache for shared subexpressions
    converted_cache: IndexMap<*const Expr, Term>,
}
```
, where `TermDag` is hashconsing arena for `Term`s provided by `egglog`.

`dag->egglog` is very straightforward: for an `Expr`, such as an `Expr::Bop(op, lhs, rhs)`, it is converted to something like `(Bop (op) (lhs) (rhs))` in egglog.

The generated egglog is very verbose. The [min.bril](https://github.com/egraphs-good/eggcc/blob/main/tests/passing/small/min.bril)'s egglog is 4000+ lines. Here I introduce the contents briefly:

> THESE DEFINITIONS ARE ALL THE SAME FOR EVERY BRIL PROGRAM.

* `Term`: `Expr | ListExpr`
* data type:
  ```
  (datatype BaseType
    (IntT) (BoolT) (FloatT)
    ; a pointer to a memory region with a particular type
    (PointerT BaseType)
    (StateT))
  (datatype Type
    ; a primitive type
    (Base BaseType)
    ; a typed tuple. Use an empty tuple as a unit type.
    ; state edge also has unit type
    ; function TNil and TCons produces TypeList
    (TupleT TypeList)
  )
  ```
* `Assumption: InFunc | InLoop | InIf | InSwitch`
* Leaf nodes:
  ```
  (function Arg (Type Assumption) Expr)
  (function Const (Constant Type Assumption) Expr)
  (function Empty (Type Assumption) Expr)
  ```
* Operators: `TernaryOp`, `BinaryOp`, `UnaryOp`
  ```
  (function Top   (TernaryOp Expr Expr Expr) Expr)
  (function Bop   (BinaryOp Expr Expr) Expr)
  (function Uop   (UnaryOp Expr) Expr)
  ; some other about tuple, alloc, call
  ```
* Control flow: if, switch, loop
  ```
  ; Switch on a list of lazily-evaluated branches.
  ; pred must be an integer
  ;                 pred  inputs   branches     chosen
  (function Switch (Expr  Expr     ListExpr)    Expr)
  ; If is like switch, but with a boolean predicate
  ;             pred inputs   then else
  (function If (Expr Expr     Expr Expr) Expr)
  ; A do-while loop.
  ; Evaluates the input, then evaluates the body.
  ; input must have the same type as (output1, output2, ..., outputi)
  ; input must be a tuple, pred must be a boolean
  ; pred-and-body must be a flat tuple (pred, out1, out2, ..., outi)
  ; input must be the same type as (out1, out2, ..., outi)
  ;                  input   pred-and-body
  (function DoWhile (Expr    Expr)                   Expr)
  ```

Generated egglog also have `Term`s.

> why need `Term`? It looks like `Expr`... Its usage need to be clarified.
{: .block-tip}

It defines and infers the sort `TermAndCost` and the function `ExtractedExpr` for cost-model-guided extraction? So `Term` is extracted `Expr`?  See the [select optimization](#select-optimization) example, it seems so.

The `term-subst` ruleset instantiates the term as an Expr in the provided context.



### Checking and Optimization

> not finished yet; this relates to compiler optimization, maybe out of our concern.
{: .block-warning}

##### Legality Checking

Implemented in rulesets:

```
(ruleset is-resolved)
(ruleset always-run) 
```

##### Type Analysis

Implemented in rulesets:
```
(ruleset type-analysis)
(ruleset type-helpers) 
```

It interfers relations:
```
;; Keep track of type expectations for error messages
(relation ExpectType (Expr Type String))
```

and type-checking rules is like:
```
(rule (
        (ExpectType e expected msg)
        (HasType e actual)
        (!= expected actual) ;; not okay unless we saturate type helpers.
      )
      ((extract "Expecting expression")
       (extract e)
       (extract "to have type")
       (extract expected)
       (extract "but got type")
       (extract actual)
       (extract "with message")
       (extract msg)
       (panic "type mismatch- check RUST_LOG=info for expressions that mismatched"))
      :ruleset error-checking)
```
and also have rules to infer and check `HasArgType` and `HasType` relations for operators and control flow nodes.




##### Add Context


Implemented in ruleset:
```
(ruleset context)
```

##### Term Substitution


> when is this used?
{: .block-tip}

Implemented in ruleset:
```
(ruleset term-subst)
```

```
; Instantiate the term as an Expr in the provided context
; where references to (Arg) in the term are replaced by Expr
(function TermSubst (Assumption Expr Term) Expr :unextractable)
```

For the example of an constant term:
```
; replace the context
(rule ((= lhs (TermSubst ctx e (TermArg))))
      ((union lhs (AddContext ctx e)))
      :ruleset term-subst)
```

##### Substitution

Implemented in rulesets:
```
;; Substitution rules allow for substituting some new expression for the argument
;; in some new context.
;; It performs the substitution, copying over the equalities from the original eclass.
;; It only places context on the leaf nodes.

(ruleset subst)
(ruleset apply-subst-unions)
(ruleset cleanup-subst)
```

```
;; (Subst assumption to in) substitutes `to` for `(Arg ty)` in `in`.
;; It also replaces the leaf context in `to` with `assumption` using `AddContext`.
;; `assumption` *justifies* this substitution, as the context that the result is used in.
;; In other words, it must refine the equivalence relation of `in` with `to` as the argument.
;;                          to   in
(function Subst (Assumption Expr Expr) Expr :unextractable)

;; Used to delay unions for the subst ruleset.
;; This is necessary because substitution may not terminate if it can
;; observe its own results- it may create infinitly large terms.
;; Instead, we phase substitution by delaying resulting unions in this table.
;; After applying this table, substitutions and this table are cleared.
(function DelayedSubstUnion (Expr Expr) Expr :unextractable)
```

The apply is multi-phase:

```
(rule ((= lhs (Subst assum to (Arg _ty _oldctx)))
       )
      ;; add the assumption `to`
      ((DelayedSubstUnion lhs (AddContext assum to))))
```

after registering the delayed unions:
```
(rule ((DelayedSubstUnion lhs rhs))
      ((union lhs rhs))
      :ruleset apply-subst-unions)
```

##### Drop

##### Interval Analysis and Rewrite

Implemented in ruleset:
```
(ruleset interval-analysis)
(ruleset interval-rewrite)
```

```
; if the predicate is true, merge with then branch
(rule (
       (= lhs (If cond inputs thn els))
       (ContextOf lhs if_ctx)
       (= (BoolB true) (lo-bound cond))
      )
      ((union lhs (Subst if_ctx inputs thn)))
      :ruleset interval-rewrite)
```

##### Switch Rewrite

Implemented in ruleset:
```
(ruleset switch_rewrite)
(ruleset always-switch-rewrite)
```

```
; if a < b then a else b ~~> (min a b)
(rule (
       (= pred (Bop (LessThan) a b))
       (= if_e (If pred inputs thn els))
       ; a is an input to the if region
       (= a (Get inputs i))
       ; b is an input to the if region
       (= b (Get inputs j))
       ; if a < b then a else b
       (= (Get thn k) (Get (Arg ty (InIf true pred inputs)) i))
       (= (Get els k) (Get (Arg ty (InIf false pred inputs)) j))
      )
      ((union (Get if_e k) (Bop (Smin) a b)))
      :ruleset switch_rewrite)
```


##### Select Optimization

Implemented in ruleset:
```
(ruleset select_opt)
```

```
(rule
       (
        (= if_e (If pred inputs thn els))
        (ContextOf if_e ctx)

        (= thn_out (Get thn i))
        (= els_out (Get els i))
        (ExprIsPure thn_out)
        (ExprIsPure els_out)
        
        (> 10 (Expr-size thn_out)) ; TODO: Tune these size limits
        (> 10 (Expr-size els_out))
        (= (TCPair t1 c1) (ExtractedExpr thn_out))
        (= (TCPair t2 c2) (ExtractedExpr els_out))
       )
       (
        (union (Get if_e i)
               (Top (Select) pred (TermSubst ctx inputs t1) (TermSubst ctx inputs t2)))
       )
       :ruleset select_opt
)
```
This is a intuitive example for using `TermSubst` ([Term Substitution](#term-substitution)).

##### Peepholes

Implemented in ruleset:
```
(ruleset peephole)
```

Example:
```
(rewrite (Bop (Mul) (Const (Int 0) ty ctx) e) (Const (Int 0) ty ctx) :ruleset peepholes)
```

##### Pointee

Implemented in ruleset:
```
(ruleset memory-helpers)
```

```
(datatype PtrPointees
  (PointsTo List<i64+IntInterval>)
  (PointsAnywhere))

; List<i64+IntInterval> is used as an association list; the i64 keys
; (corresponding to alloc ids) are always unique and sorted, the IntInterval
; values correspond to offset ranges.
; PtrPointees 
;
; (TuplePointsTo [{0->[4,5], 1->[0,0]}, {0->[0,0]}])
; indicates a tuple with two components.
; - The first component might point to Alloc 0 at offsets 4 or 5,
;   or Alloc 1 at offset 0
; - The second component points to Alloc 0 at offset 0
(datatype Pointees
          (TuplePointsTo List<PtrPointees>)
          (PtrPointsTo PtrPointees))
```

Here's a link to the related PR: [Pointer Analysis](https://github.com/egraphs-good/eggcc/pull/434#issue-2228859498), where it says:
- `PtrPointees` represents where a single pointer can point;
- `Pointees` represents where an Expr can point to.

As an example: `(TuplePointsTo [(PointsTo {0->[4,5], 1->[0,0]}), (PointsAnywhere)])` indicates a tuple with two components:
- The first component might point to Alloc 0 at offset 4 or 5 or Alloc 1 at offset 0.
- The second component might point anywhere.

The key function of the pointer analysis is:

```
(function PointsToCells (Expr Pointees) Pointees)
```

`(= pointees (PointsToCells e arg-pointees))` indicates that when the `(Arg)` contained in `e` points to `arg-pointees`, `e` points to `pointees`.

> don't understand this...
{: .block-warning}

why?
```
(rule ((PointsToCells (Bop (Load) e state) ap))
      ((PointsToCells e ap)
       (PointsToCells state ap))
      :ruleset memory-helpers)
```

##### Invariant Analysis

```
;; bool: whether the term in the Expr is an invariant.
(function is-inv-Expr (Expr Expr) bool :unextractable :merge (or old new))
(function is-inv-ListExpr (Expr ListExpr) bool :unextractable :merge (or old new))
```

##### Boundary Analysis

Implemented in ruleset:
```
(ruleset boundary-analysis)
```

##### Loop Optimization

Implemented in ruleset:
```
(ruleset loop-unroll)
(ruleset loop-peel)
(ruleset loop-iters-analysis)
```
